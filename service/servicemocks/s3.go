// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package servicemocks

import (
	"context"
	"io"
	"sync"
	"tg-podcastotron/service"
)

// Ensure, that MockS3Store does implement service.S3Store.
// If this is not the case, regenerate this file with moq.
var _ service.S3Store = &MockS3Store{}

// MockS3Store is a mock implementation of service.S3Store.
//
//	func TestSomethingThatUsesS3Store(t *testing.T) {
//
//		// make and configure a mocked service.S3Store
//		mockedS3Store := &MockS3Store{
//			DeleteFunc: func(ctx context.Context, key string) error {
//				panic("mock out the Delete method")
//			},
//			PreSignedURLFunc: func(key string) (string, error) {
//				panic("mock out the PreSignedURL method")
//			},
//			PutFunc: func(ctx context.Context, key string, dataReader io.ReadSeeker, opts ...func(*service.PutOptions)) error {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedS3Store in code that requires service.S3Store
//		// and then make assertions.
//
//	}
type MockS3Store struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, key string) error

	// PreSignedURLFunc mocks the PreSignedURL method.
	PreSignedURLFunc func(key string) (string, error)

	// PutFunc mocks the Put method.
	PutFunc func(ctx context.Context, key string, dataReader io.ReadSeeker, opts ...func(*service.PutOptions)) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// PreSignedURL holds details about calls to the PreSignedURL method.
		PreSignedURL []struct {
			// Key is the key argument value.
			Key string
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// DataReader is the dataReader argument value.
			DataReader io.ReadSeeker
			// Opts is the opts argument value.
			Opts []func(*service.PutOptions)
		}
	}
	lockDelete       sync.RWMutex
	lockPreSignedURL sync.RWMutex
	lockPut          sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *MockS3Store) Delete(ctx context.Context, key string) error {
	if mock.DeleteFunc == nil {
		panic("MockS3Store.DeleteFunc: method is nil but S3Store.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedS3Store.DeleteCalls())
func (mock *MockS3Store) DeleteCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// PreSignedURL calls PreSignedURLFunc.
func (mock *MockS3Store) PreSignedURL(key string) (string, error) {
	if mock.PreSignedURLFunc == nil {
		panic("MockS3Store.PreSignedURLFunc: method is nil but S3Store.PreSignedURL was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockPreSignedURL.Lock()
	mock.calls.PreSignedURL = append(mock.calls.PreSignedURL, callInfo)
	mock.lockPreSignedURL.Unlock()
	return mock.PreSignedURLFunc(key)
}

// PreSignedURLCalls gets all the calls that were made to PreSignedURL.
// Check the length with:
//
//	len(mockedS3Store.PreSignedURLCalls())
func (mock *MockS3Store) PreSignedURLCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockPreSignedURL.RLock()
	calls = mock.calls.PreSignedURL
	mock.lockPreSignedURL.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *MockS3Store) Put(ctx context.Context, key string, dataReader io.ReadSeeker, opts ...func(*service.PutOptions)) error {
	if mock.PutFunc == nil {
		panic("MockS3Store.PutFunc: method is nil but S3Store.Put was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		DataReader io.ReadSeeker
		Opts       []func(*service.PutOptions)
	}{
		Ctx:        ctx,
		Key:        key,
		DataReader: dataReader,
		Opts:       opts,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(ctx, key, dataReader, opts...)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedS3Store.PutCalls())
func (mock *MockS3Store) PutCalls() []struct {
	Ctx        context.Context
	Key        string
	DataReader io.ReadSeeker
	Opts       []func(*service.PutOptions)
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		DataReader io.ReadSeeker
		Opts       []func(*service.PutOptions)
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}
